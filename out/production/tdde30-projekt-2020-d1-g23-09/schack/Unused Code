/*public boolean istLegal(int prevX, int prevY){
	return Math.abs(getPieceX() - prevX) == Math.abs(getPieceY() - prevY) && color == board.getState();
    }

    public boolean isLegal(int prevX, int prevY){
	if ((Math.abs(prevX - getPieceX()) - Math.abs(prevY - getPieceY()) == 0) &&
	    isValidDestination() && color == board.getState()) {
	    boolean freePath = true;
	    if (prevX < getPieceX() && prevY < getPieceY()) {
		for (int i = prevX+1; i < getPieceX(); i++) {
		    if (board.getPieceTypeAt(i, prevY + i-prevX ) != PieceType.EMPTY) {
			freePath = false;
			break;
		    }
		}
	    }
	    if (prevX > getPieceX() && prevY < getPieceY()) {
		for (int i = prevX-1; i > getPieceX(); i--) {
		    if (board.getPieceTypeAt(i, prevY + prevX-i ) != PieceType.EMPTY) {
			freePath = false;
			break;
		    }
		}
	    }
	    if (prevX < getPieceX() && prevY > getPieceY()) {
		for (int i = prevX+1; i < getPieceX(); i++) {
		    if (board.getPieceTypeAt(i, prevY - i+prevX ) != PieceType.EMPTY) {
			freePath = false;
			break;
		    }
		}
	    }
	    if (prevX > getPieceX() && prevY > getPieceY()) {
		for (int i = prevX-1; i > getPieceX(); i--) {
		    if (board.getPieceTypeAt(i, prevY - prevX+i ) != PieceType.EMPTY) {
			freePath = false;
			break;
		    }
		}
	    } return freePath;
	} else {
	    return false;
	}
    }
    */


    KING:
        /*public boolean isLegal(int prevX, int prevY){
            if (color == board.getState() && isValidDestination()) {
    	    if ((getPieceX() == prevX && Math.abs(getPieceY() - prevY) == 1)){
    		return true;
    	    }
    	    else if ((getPieceY() == prevY && Math.abs(getPieceX() - prevX) == 1)){
    		return true;
    	    }
    	    else if(board.isCastlingPossible()){
    		return true;
    	    }
    	    else return Math.abs(getPieceX() - prevX) == 1 && Math.abs(getPieceY() - prevY) == 1;
    	} return false;
        } */


        KNIGHT:
            /*public boolean isLegal(int prevX, int prevY){
        	return ((Math.abs(getPieceX() - prevX) == 1 && Math.abs(getPieceY() - prevY) == 2) ||
        		(Math.abs(getPieceX() - prevX) == 2 && Math.abs(getPieceY() - prevY) == 1))
        	       && color == board.getState() && isValidDestination();
            }*/

            PAWN:
             /*public boolean isLegal(int prevX, int prevY) {
                    if (color == "black" && color == board.getState()) {
                        if (getPieceX() == prevX && board.getPieceTypeAt(getPieceX(), getPieceY()) == PieceType.EMPTY) {
                            if (firstStep) {
                                if (getPieceY() == prevY + 1 || (Math.abs(getPieceX() - prevX) == 1 && getPieceY() == prevY + 1
                                                                 && board.getPieceAt(getPieceX(), getPieceY()).getColor() == "white")) {
                                    firstStep = false;
                                    return true;
                                } else if (getPieceY() == prevY + 2
                                           && board.getPieceTypeAt(getPieceX(), getPieceY() - 1) == PieceType.EMPTY) {
                                    firstStep = false;
                                    return true;
                                } else {
                                    return false;
                                }
                            } else {
                                return (getPieceY() == prevY + 1);
                            }
                        } else return (Math.abs(getPieceX() - prevX) == 1 && getPieceY() == prevY + 1 &&
                                    board.getPieceAt(getPieceX(), getPieceY()).getColor() == "white");
                    } else if (color == "white" && color == board.getState()) {
                        if (getPieceX() == prevX && board.getPieceTypeAt(getPieceX(), getPieceY()) == PieceType.EMPTY) {
                            if (firstStep) {
                                if (getPieceY() == prevY - 1 || (Math.abs(getPieceX() - prevX) == 1 && getPieceY() == prevY - 1 &&
                                                                 board.getPieceAt(getPieceX(), getPieceY()).getColor() == "black")) {
                                    firstStep = false;
                                    return true;
                                } else if (getPieceY() == prevY - 2
                                           && board.getPieceTypeAt(getPieceX(), getPieceY() + 1) == PieceType.EMPTY) {
                                    firstStep = false;
                                    return true;
                                } else {
                                    return false;
                                }
                            } else {
                                return (getPieceY() == prevY - 1);
                            }
                        } else return (Math.abs(getPieceX() - prevX) == 1 && getPieceY() == prevY - 1 &&
                                       board.getPieceAt(getPieceX(), getPieceY()).getColor() == "black");
                    }
                    return false;
                }*/

    QUEEN:
    /*if (((getPieceX() == prevX || getPieceY() == prevY)) && color == Board.getState()){
    	    return true;
    	}
    	return ((Math.abs(getPieceX() - prevX) == Math.abs(getPieceY() - prevY)) && color == Board.getState());
        }
    	public boolean isLegal(int prevX, int prevY){
    	    boolean freePath = true;
    	    if ((Math.abs(prevX - getPieceX()) - Math.abs(prevY - getPieceY()) == 0) && isValidDestination() && color == board.getState()) {
    		if (prevX < getPieceX() && prevY < getPieceY()) {
    		    for (int i = prevX + 1; i < getPieceX(); i++) {
    			if (board.getPieceTypeAt(i, prevY + i - prevX) != PieceType.EMPTY) {
    			    freePath = false;
    			    break;
    			}
    		    }
    		}
    		if (prevX > getPieceX() && prevY < getPieceY()) {
    		    for (int i = prevX - 1; i > getPieceX(); i--) {
    			if (board.getPieceTypeAt(i, prevY + prevX - i) != PieceType.EMPTY) {
    			    freePath = false;
    			    break;
    			}
    		    }
    		}
    		if (prevX < getPieceX() && prevY > getPieceY()) {
    		    for (int i = prevX + 1; i < getPieceX(); i++) {
    			if (board.getPieceTypeAt(i, prevY - i + prevX) != PieceType.EMPTY) {
    			    freePath = false;
    			    break;
    			}
    		    }
    		}
    		if (prevX > getPieceX() && prevY > getPieceY()) {
    		    for (int i = prevX - 1; i > getPieceX(); i--) {
    			if (board.getPieceTypeAt(i, prevY - prevX + i) != PieceType.EMPTY) {
    			    freePath = false;
    			    break;
    			}
    		    }
    		}
    		return freePath;
    	    } if (isValidDestination() && color == board.getState() &&
    		  ((Math.abs(prevX - getPieceX()) != 0 && Math.abs(prevY - getPieceY()) == 0) ||
    		   (Math.abs(prevX - getPieceX()) == 0 && Math.abs(prevY - getPieceY()) != 0))) {
    		if (prevX < getPieceX() && getPieceY() == prevY) {
    		    for (int i = getPieceX() - 1; i > prevX; i--) {
    			if (board.getPieceTypeAt(i, getPieceY()) != PieceType.EMPTY) {
    			    freePath = false;
    			    break;
    			}
    		    }
    		}
    		if (prevX > getPieceX() && getPieceY() == prevY) {
    		    for (int i = getPieceX() + 1; i < prevX; i++) {
    			if (board.getPieceTypeAt(i, getPieceY()) != PieceType.EMPTY) {
    			    freePath = false;
    			    break;
    			}
    		    }
    		}
    		if (prevY > getPieceY() && getPieceX() == prevX) {
    		    for (int i = getPieceY() + 1; i < prevY; i++) {
    			if (board.getPieceTypeAt(getPieceX(), i) != PieceType.EMPTY) {
    			    freePath = false;
    			    break;
    			}
    		    }
    		}
    		if (prevY < getPieceY() && getPieceX() == prevX) {
    		    for (int i = getPieceY() - 1; i > prevY; i--) {
    			if (board.getPieceTypeAt(getPieceX(), i) != PieceType.EMPTY) {
    			    freePath = false;
    			    break;
    			}
    		    }
    		} return freePath;
    	    }
    	    else {
    	        return false;
    	    }
    	}
    	*/

 ROOK:

 /*public boolean isLegal(int prevX, int prevY) {
 	if (isValidDestination() && color == board.getState() &&
 	    ((Math.abs(prevX - getPieceX()) != 0 && Math.abs(prevY - getPieceY()) == 0) ||
 	     (Math.abs(prevX - getPieceX()) == 0 && Math.abs(prevY - getPieceY()) != 0))) {
 	    boolean freePath = true;
 	    if (prevX < getPieceX() && getPieceY() == prevY) {
 		for (int i = getPieceX() - 1; i > prevX; i--) {
 		    if (board.getPieceTypeAt(i, getPieceY()) != PieceType.EMPTY) {
 			freePath = false;
 			break;
 		    }
 		}
 	    }
 	    if (prevX > getPieceX() && getPieceY() == prevY) {
 		for (int i = getPieceX() + 1; i < prevX; i++) {
 		    if (board.getPieceTypeAt(i, getPieceY()) != PieceType.EMPTY) {
 			freePath = false;
 			break;
 		    }
 		}
 	    }
 	    if (prevY > getPieceY() && getPieceX() == prevX) {
 		for (int i = getPieceY() + 1; i < prevY; i++) {
 		    if (board.getPieceTypeAt(getPieceX(), i) != PieceType.EMPTY) {
 			freePath = false;
 			break;
 		    }
 		}
 	    }
 	    if (prevY < getPieceY() && getPieceX() == prevX) {
 		for (int i = getPieceY() - 1; i > prevY; i--) {
 		    if (board.getPieceTypeAt(getPieceX(), i) != PieceType.EMPTY) {
 			freePath = false;
 			break;
 		    }
 		}
 	    }	return freePath;

 	} else {
 	    return false;
 	}
 	}
      */



      ANVÄNDS I PIECEMOVE:
      	/*System.out.println("Ett");
      	System.out.println("före: (prev) " + dragPiece.getPreviousLegalMoves());
      	System.out.println("före:  " + dragPiece.getlegalMoves());
      	updateAllLegalMoves();
      	System.out.println("efter /prev: " + dragPiece.getPreviousLegalMoves());
      	System.out.println("efter:  " + dragPiece.getlegalMoves());
      	if (board.isChecked(whiteKing) && board.getState() == "white") {
      	    revertAllLegalMoves();
      	    dragPiece.newX(oldX);
      	    dragPiece.newY(oldY);
      	    board.changeState();
      	    JOptionPane.showMessageDialog(null, "Illegal move.");
      	}
      	System.out.println("två");
      	revertAllLegalMoves();
      	System.out.println("efter /prev: " + dragPiece.getPreviousLegalMoves());
      	System.out.println("efter:  " + dragPiece.getlegalMoves());

      */